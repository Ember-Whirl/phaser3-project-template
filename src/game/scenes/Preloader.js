import { Scene } from 'phaser';
import ResponsiveManager from '../managers/ResponsiveManager.js';
import ProgressBar from '../ui/components/ProgressBar.js';

export class Preloader extends Scene
{
    constructor ()
    {
        super('Preloader');
    }

    init ()
    {
        //  Initialize responsive manager
        ResponsiveManager.init(this);

        const { width, height } = this.scale;

        //  We loaded this image in our Boot Scene, so we can display it here
        const bg = this.add.image(width / 2, height / 2, 'background');
        bg.setDisplaySize(width, height);

        //  Create progress bar using ProgressBar component
        const barWidth = Math.min(468, width - 100);
        this.progressBar = new ProgressBar(this, width / 2, height / 2, {
            width: barWidth,
            height: 32,
            fillColor: 0xffffff,
            backgroundColor: 0x222222,
            showLabel: true,
            labelFormat: 'percent'
        });

        //  Track progress bar for auto-repositioning
        ResponsiveManager.trackElement(this.progressBar, 'center', { x: 0, y: 0 });

        //  Use the 'progress' event emitted by the LoaderPlugin to update the loading bar
        this.load.on('progress', (progress) => {
            this.progressBar.setValue(progress, true);
        });

        //  Setup resize listener
        this.scale.on('resize', this.onResize, this);
    }

    preload ()
    {
        //  Load the assets for the game - Replace with your own assets
        this.load.setPath('assets');

        this.load.image('logo', 'logo.png');

        //  Load the asset manifest first, then load assets based on environment
        //  The manifest is auto-generated by running: npm run pack
        this.load.json('assetManifest', 'atlases/manifest.json');

        //  Track if we've loaded the manifest assets yet
        this.manifestAssetsLoaded = false;
        this.mainMenuStarted = false;

        //  Listen for when manifest is loaded to load the actual assets
        this.load.once('complete', () => {
            this.loadAssetsFromManifest();
            this.manifestAssetsLoaded = true;
            
            //  Listen for when ALL assets (including manifest assets) finish loading
            //  Use 'on' instead of 'once' because we need it to fire after load.start()
            this.load.on('complete', () => {
                if (this.manifestAssetsLoaded && !this.mainMenuStarted) {
                    //  All assets are now loaded, safe to start MainMenu
                    this.mainMenuStarted = true;
                    this.scene.start('MainMenu');
                }
            });
        });
    }

    /**
     * Check if we're in production mode
     * Webpack sets process.env.NODE_ENV to 'production' during production builds
     */
    isProduction ()
    {
        return process.env.NODE_ENV === 'production';
    }

    /**
     * Load assets from the auto-generated manifest
     * This method is called after the manifest.json is loaded
     * It automatically loads all images from the folders you've set up
     */
    loadAssetsFromManifest ()
    {
        const manifest = this.cache.json.get('assetManifest');

        if (!manifest) {
            console.warn('[Assets] No manifest found. Add images to src/assets/images-source/ and run: npm run pack');
            return;
        }

        // Support both old and new manifest formats
        const atlases = manifest.atlases || manifest;
        const images = manifest.images || manifest;
        const folders = Object.keys(atlases);

        if (folders.length === 0) {
            console.warn('[Assets] Manifest is empty. Add PNG files to folders in src/assets/images-source/');
            return;
        }

        // Load atlases in both modes since individual image files don't exist
        // Individual images would be loaded from images-source/, but those files are missing
        // The atlas contains all the frames we need
        this.loadAtlasesFromManifest(atlases, images, folders);

        //  Start the actual loading
        this.load.start();
    }

    /**
     * Load texture atlases (used in production)
     * Automatically loads all atlases defined in the manifest
     */
    loadAtlasesFromManifest (atlases, images, folders)
    {
        console.log('[Assets] Loading from texture atlases (production mode)');

        folders.forEach(folder => {
            const folderAtlases = atlases[folder];
            const imageCount = images[folder] ? images[folder].length : 0;

            if (Array.isArray(folderAtlases)) {
                // Multiple batched atlases
                folderAtlases.forEach(atlasName => {
                    const atlasPath = `atlases/${atlasName}`;
                    this.load.atlas(atlasName, `${atlasPath}.png`, `${atlasPath}.json`);
                });
                console.log(`  - Loading ${folderAtlases.length} atlases for ${folder}/ (${imageCount} images total)`);
            } else {
                // Single atlas (old format or single atlas)
                const atlasPath = `atlases/${folder}`;
                this.load.atlas(folder, `${atlasPath}.png`, `${atlasPath}.json`);
                console.log(`  - Loading atlas: ${folder} (${imageCount} images)`);
            }
        });
    }

    /**
     * Load individual images (used in development)
     * Automatically loads all images defined in the manifest
     */
    loadIndividualImagesFromManifest (images, folders)
    {
        console.log('[Assets] Loading individual images (development mode)');

        folders.forEach(folder => {
            const folderImages = images[folder];
            console.log(`  - Loading from ${folder}/ (${folderImages.length} images)`);

            folderImages.forEach(imageName => {
                const imagePath = `images-source/${folder}/${imageName}.png`;
                this.load.image(imageName, imagePath);
            });
        });
    }

    create ()
    {
        //  When all the assets have loaded, it's often worth creating global objects here that the rest of the game can use.
        //  For example, you can define global animations here, so we can use them in other scenes.

        //  Note: MainMenu is now started from the 'complete' event listener in preload()
        //  after all assets (including manifest assets) finish loading
    }

    onResize (gameSize)
    {
        //  ResponsiveManager auto-updates tracked elements
        //  Add custom resize logic here if needed
    }

    shutdown ()
    {
        //  Clean up resize listener
        this.scale.off('resize', this.onResize, this);
    }
}
